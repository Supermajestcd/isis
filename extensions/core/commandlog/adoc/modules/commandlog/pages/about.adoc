[[commandlog]]
= Command Log

:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.


The _commandlog_ module provides an implementation of xref:refguide:applib:index/services/publishing/spi/CommandSubscriber.adoc[] SPI that persists xref:refguide:applib:index/services/command/Command.adoc[Command]s using either the xref:pjpa:ROOT:about.adoc[JPA/EclipseLink] or xref:pjdo:ROOT:about.adoc[JDO/DataNucleus] object store.
This can be useful for auditing.



include::docs:mavendeps:partial$setup-and-configure-dependencyManagement.adoc[leveloffset=+1]

In addition, add a section for secman's own BOM:

[source,xml,subs="attributes+"]
.pom.xml
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.apache.causeway.extensions</groupId>
            <artifactId>causeway-extensions-commandlog</artifactId>
            <scope>import</scope>
            <type>pom</type>
            <version>{page-causewayrel}</version>
        </dependency>
    </dependencies>
</dependencyManagement>
----

[#dependencies]
== Dependencies

In the webapp module of your application, add the following dependency:

[source,xml]
.pom.xml
----
<dependencies>
    <dependency>
        <groupId>org.apache.causeway.extensions</groupId>
        <artifactId>causeway-extensions-commandlog-persistence-XXX</artifactId>    <!--.-->
    </dependency>
</dependencies>
----
<.> specify either `causeway-extensions-commandlog-persistence-jpa` or `causeway-extensions-commandlog-persistence-jdo`, as required


[[_update-appmanifest]]
== Update AppManifest


In your application's `AppManifest` (top-level Spring `@Configuration` used to bootstrap the app), import the CommandLog modules.
You will also need to import the fixture module; SecMan uses fixture scripts to seed its entities:

[source,java]
.AppManifest.java
----
@Configuration
@Import({
        ...
        CausewayModuleExtCommandLogPersistenceXxx.class,        // <.>
        ...
})
public class AppManifest {
}
----

<.> specify either `CausewayModuleExtCommandLogPersistenceJdo` or `CausewayModuleExtCommandLogPersistenceJpa`, as required


[#configure-properties]
== Configuration Properties

Add the database schema used by the CommandLog entities to the configuration file:

[source,yaml]
.application.yml
----
causeway:
  persistence:
    schema:
      auto-create-schemas: causewayExtCommandLog
----

Optionally, modify the configuration properties for CommandLog itself:

[source,yaml]
.application.yml
----
causeway:
  extensions:
    command-log:
      publish-policy: "always"    # <.>
----


<.> the alternative is `"only-if-system-changed"`, which suppresses the persisting of `CommandLogEntry`s for commands where no other system state was changed (for example a finder action with safe semantics).
+
See xref:refguide:config:sections/causeway.extensions.adoc#causeway.extensions.command-log.publish-policy[causeway.extensions.command-log.publish-policy] configuration property for more details.


== Background Commands

Sometimes we might want to execute an action not immediately in the current users's thread of control, but instead to perform it in the background; for example any long-running process.

One way to accomplish this is to use xref:refguide:applib:index/services/wrapper/WrapperFactory.adoc#asyncWrap_T_AsyncControl[WrapperFactory#asyncWrap(...)], where the command is executed by another thread obtained from a thread pool (`ForkJoinPool.commonPool()`).
This works well, but has the slight risk that it is not transactionally safe - the async thread executes in its own interaction/transaction, and so might fail even though the initiating command succeeds; or vice versa.

An alternative approach is to use the xref:refguide:extensions:index/commandlog/applib/dom/BackgroundService.adoc[BackgroundService].
This persists the command as an `CommandLogEntry` instance, indicating that it is to be executed in the background.
Then, a separate thread - eg scheduling using Quartz - can pick up the queued `CommandLogEntry` and execute it.

=== Submitting Actions

For example, suppose we have a long-running action to export all the invoices we have received from a supplier, perhaps to be sent to some other system.
Assuming that the `exportInvoices()` action is a regular action on the `Supplier` domain class, we would use:

[source,java]
.example usage of `BackgroundService` to invoke a regular action
----
@Action
public void exportInvoices(Supplier supplier) {
    backgroundService.execute(supplier).exportInvoices();
}
----

If instead this functionality is implemented as a mixin, we would use something like:

[source,java]
.example usage of `BackgroundService` to invoke a mixin action:
----
@Action
public void exportInvoices(Supplier supplier) {
    backgroundService.executeMixin(Supplier_exportInvoices.class, supplier).act();
}
----

The action being invoked must be part of the Causeway metamodel, in other words it cannot be marked uses
xref:refguide:applib:index/annotation/Programmatic.adoc[] or xref:refguide:applib:index/annotation/Domain_Exclude.adoc[].

By default all the usual hide/disable/validate rules will be checked, but there are also methods to allow these rules to be skipped.

Behind the scenes this service uses xref:refguide:applib:index/services/wrapper/WrapperFactory.adoc#asyncWrap_T_AsyncControl[WrapperFactory#asyncWrap(...)] using xref:refguide:applib:index/services/wrapper/control/AsyncControl.adoc#with_ExecutorService[AsyncControl#with(ExecutorService)] to pass an implementation of `ExecutorService` that persists the command as a `CommandLogEntry` instance.

If you require more fine-grained control, you can always just use the xref:refguide:applib:index/services/wrapper/WrapperFactory.adoc[WrapperFactory] async method yourself.
The `ExecutorService` to use is xref:refguide:extensions:index/commandlog/applib/dom/BackgroundService_PersistCommandExecutorService.adoc[BackgroundService.PersistCommandExecutorService].
This is a Spring `@Service` and so can be obtained through injection.

=== Executing Actions using the Quartz scheduler

Once a command has been persisted as a `CommandLogEntry`, we require some other process to actually execute the command.
The _commandlog_ module includes the `RunBackgroundCommandsJob`, a https://www.quartz-scheduler.org/[Quartz] job that does exactly this.
Each time it is called it will query for any background commands that have not been started, and will execute each (using the xref:refguide:applib:index/services/command/CommandExecutorService.adoc[CommandExecutorService]).

The job is marked as non re-entrant, so it doesn't matter how often it is called; we recommend a 10 second delay usually works fine.

To configure Quartz, add the following to your `AppManifest`:

[source,java]
.AppManifest.java
----
public class AppManifest {

    @Bean(name = "RunBackgroundCommandsJob")                                // <.>
    public JobDetailFactoryBean jobDetail() {
        val jobDetailFactory = new JobDetailFactoryBean();
        jobDetailFactory.setJobClass(RunBackgroundCommandsJob.class);
        jobDetailFactory.setDurability(true);
        return jobDetailFactory;
    }

    @Bean
    public SimpleTriggerFactoryBean trigger(
            final @Qualifier("RunBackgroundCommandsJob") JobDetail job) {   // <1>
        val trigger = new SimpleTriggerFactoryBean();
        trigger.setJobDetail(job);
        trigger.setStartDelay(60_000);                                      // <.>
        trigger.setRepeatInterval(10_000);                                  // <.>
        trigger.setRepeatCount(REPEAT_INDEFINITELY);
        return trigger;
    }

    // ...
}
----

<.> name and qualify the job (so will not interfere with any other Quartz jobs you may have defined)
<.> 60 secs to wait for the app to be ready
<.> check every 10 seconds



==== Disabling Quartz

The _commandlog_ module automatically references the https://www.quartz-scheduler.org/[Quartz] library.
If you don't want to use this functionality and want to exclude quartz, then add an explicit dependency on the _commandlog_ applib but exclude the quartz dependency within it:

[source,xml]
.pom.xml
----
<dependencies>
    <dependency>
        <groupId>org.apache.causeway.extensions</groupId>
        <artifactId>causeway-extensions-commandlog-applib</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.quartz-scheduler</groupId>                 <!--.-->
                <artifactId>quartz</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>
----
<.> exclude reference to quartz



== Notes

Conceptually a *command* represents the _intention_ to execute an action or to edit a property ("before" the change), while an *interaction execution* represents the actual execution itself ("after" the change).

The xref:refguide:applib:index/services/publishing/spi/CommandSubscriber.adoc[] SPI and xref:refguide:applib:index/services/publishing/spi/ExecutionSubscriber.adoc[] SPI allow either to be subscribed to.
From an auditing perspective, their behaviour is quite similar:

* even though a command represents the _intention_ to invoke an action, its xref:refguide:applib:index/services/publishing/spi/CommandSubscriber.adoc[CommandSubscriber] SPI is only called once the action/property edit has been completed.

* the xref:refguide:applib:index/services/publishing/spi/ExecutionSubscriber.adoc[] is called as soon as the action has completed.
In most interactions there will only be a single action called within the interaction, hence these two subscribers will be called at almost the same time with very similar payloads.

However, there can be some subtle differences:

* the xref:refguide:applib:index/services/wrapper/WrapperFactory.adoc[] service allows actions to be invoked "as if" through the user interface.
Therefore one action can execute another can execute another, creating a nested call graph of executions.
+
The  xref:refguide:applib:index/services/publishing/spi/ExecutionSubscriber.adoc[] is called after each and every execution as it completes, so will be called several times.

* In contrast, the xref:refguide:applib:index/services/publishing/spi/CommandSubscriber.adoc[CommandSubscriber] is called only once, for the top-level (outermost) action.




== See also

* xref:refguide:applib:index/services/wrapper/WrapperFactory.adoc[] service
* xref:refguide:extensions:index/commandlog/applib/dom/BackgroundService.adoc[BackgroundService] service
* xref:refguide:applib:index/services/publishing/spi/CommandSubscriber.adoc[] SPI
* xref:refguide:applib:index/services/publishing/spi/ExecutionSubscriber.adoc[] SPI
* xref:executionlog:about.adoc[] extension









